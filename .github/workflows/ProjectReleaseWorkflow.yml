name: Project Release Workflow
on:
  push:
    branches:
      - release  

jobs:
  # build-and-test:
  #   runs-on: ubuntu-latest

  #   steps:
  #     - name: Check out the code
  #       uses: actions/checkout@v2

  #     - name: Set up Docker
  #       uses: docker/setup-buildx-action@v2

  #     - name: Set up Docker Compose
  #       run: |
  #         sudo apt-get update
  #         sudo apt-get install -y docker-compose

  #     - name: Log in to Docker Hub
  #       uses: docker/login-action@v2
  #       with:
  #         username: ${{ secrets.DOCKERHUB_USERNAME }} 
  #         password: ${{ secrets.DOCKERHUB_TOKEN }} 

  #     - name: Build and run Docker Compose
  #       run: |
  #         docker-compose -f docker-compose.yml up -d --build
  #         docker-compose logs
  #         echo "Waiting for AWS connection..."
          
  #         MAX_RETRIES=12  # Waits up to 60 seconds (12 retries * 5 seconds)
  #         RETRY_COUNT=0

  #         while ! docker-compose logs | grep -q "Connected to PostgreSQL"; do
  #           if docker-compose logs | grep -q "Database connection error"; then
  #             echo "âŒ Database connection failed. Stopping GitHub Actions."
  #             exit 1  # This will stop GitHub Actions with a failure
  #           fi

  #           if [ "$RETRY_COUNT" -ge "$MAX_RETRIES" ]; then
  #             echo "âŒ Timed out waiting for AWS connection. Stopping GitHub Actions."
  #             exit 1
  #           fi

  #           echo "â³ Waiting for AWS connection... (Attempt $((RETRY_COUNT+1))/$MAX_RETRIES)"
  #           sleep 5
  #           RETRY_COUNT=$((RETRY_COUNT+1))
  #         done

  #         echo "âœ… AWS connection established."

  #     - name: Push Docker images to Docker Hub
  #       run: |
  #         docker-compose -f docker-compose.yml push
          
  #     - name: Shut down Docker Compose
  #       run: |
  #         docker-compose down
    
  # snyk_scan:
  #   needs: build-and-test
  #   runs-on: ubuntu-latest
  #   steps:   
  #   - name: Run Snyk to check backend Docker image for vulnerabilities
  #     uses: snyk/actions/docker@master
  #     continue-on-error: true
  #     env:
  #       SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
  #     with:
  #       image: ${{ secrets.DOCKERHUB_USERNAME }}/backend:0.1

  #   - name: Run Snyk to check frontend Docker image for vulnerabilities
  #     uses: snyk/actions/docker@master
  #     continue-on-error: true
  #     env:
  #       SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
  #     with:
  #       image: ${{ secrets.DOCKERHUB_USERNAME }}/frontend:0.1

  #   - name: Delete frontend image from Docker Hub
  #     run: |
  #       IMAGE_NAME="vinetage/frontend"
  #       TAG="0.1"
  #       curl -X DELETE "https://hub.docker.com/v2/repositories/${IMAGE_NAME}/tags/${TAG}/" \
  #            -H "Authorization: Bearer ${{ secrets.DOCKERHUB_TOKEN }}"

  #   - name: Delete backend image from Docker Hub
  #     run: |
  #       IMAGE_NAME="vinetage/backend"
  #       TAG="0.1"
  #       curl -X DELETE "https://hub.docker.com/v2/repositories/${IMAGE_NAME}/tags/${TAG}/" \
  #            -H "Authorization: Bearer ${{ secrets.DOCKERHUB_TOKEN }}"

  deploy-to-ec2:
    # needs: snyk_scan
    runs-on: ubuntu-latest
    environment:
      name: EC2_Deployment
    steps:
      - name: Set up AWS CLI
        run: |
          curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          unzip -o awscliv2.zip
          sudo ./aws/install --update

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Terminate existing EC2 instance (if any)
        run: |
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=nus-swe5006" "Name=instance-state-name,Values=running,pending" \
            --query "Reservations[*].Instances[*].InstanceId" \
            --output text)
      
          if [ -n "$INSTANCE_ID" ]; then
            echo "Terminating existing instance: $INSTANCE_ID"
            aws ec2 terminate-instances --instance-ids $INSTANCE_ID
            aws ec2 wait instance-terminated --instance-ids $INSTANCE_ID
          else
            echo "No existing instance found."
          fi

      - name: Launch EC2 Instance
        id: launch
        run: |
          AMI_ID=$(aws ec2 describe-images --owners amazon \
            --filters "Name=name,Values=ubuntu/images/hvm-ssd/ubuntu-jammy-22.04-amd64-server-*" \
            --query 'Images[*].[ImageId,CreationDate]' \
            --output text | sort -k2 -r | head -n1 | awk '{print $1}')

          INSTANCE_ID=$(aws ec2 run-instances \
            --image-id $AMI_ID \
            --instance-type t2.micro \
            --key-name ${{ secrets.EC2_KEY_PAIR_NAME }} \
            --security-groups launch-wizard-2 \
            --query 'Instances[0].InstanceId' \
            --output text)

          echo "INSTANCE_ID=$INSTANCE_ID" >> $GITHUB_ENV
          
          # Tag the instance
          aws ec2 create-tags --resources $INSTANCE_ID --tags Key=Name,Value=nus-swe5006

          PUBLIC_IP=$(aws ec2 describe-instances \
            --instance-ids $INSTANCE_ID \
            --query "Reservations[0].Instances[0].PublicIpAddress" \
            --output text)

          echo "PUBLIC_IP=$PUBLIC_IP" >> $GITHUB_ENV

      - name: Save PEM file
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_PEM_FILE }}" > ~/.ssh/ec2-key.pem
          chmod 600 ~/.ssh/ec2-key.pem

      - name: Wait for EC2 to be reachable
        run: |
          echo "Waiting for SSH at $PUBLIC_IP..."
          for i in {1..15}; do
            ssh -o StrictHostKeyChecking=no -i ~/.ssh/ec2-key.pem ubuntu@$PUBLIC_IP 'echo ready' && break
            echo "Retrying SSH..."
            sleep 10
          done

      - name: Deploy app on EC2
        run: |
          ssh -o StrictHostKeyChecking=no -i ~/.ssh/ec2-key.pem ubuntu@$PUBLIC_IP << 'EOF'
            export PUBLIC_IP=$(curl -s http://169.254.169.254/latest/meta-data/public-ipv4)
            sudo apt update
            sudo apt install -y git curl

            # Install Docker
            curl -fsSL https://get.docker.com -o get-docker.sh
            sudo sh get-docker.sh

            # Add Docker group
            sudo groupadd docker || true
            sudo usermod -aG docker ubuntu
            newgrp docker

            # Install Docker Compose v2 (CLI plugin)
            DOCKER_CONFIG=\${DOCKER_CONFIG:-\$HOME/.docker}
            mkdir -p \$DOCKER_CONFIG/cli-plugins
            curl -SL https://github.com/docker/compose/releases/download/v2.23.3/docker-compose-linux-x86_64 \
              -o \$DOCKER_CONFIG/cli-plugins/docker-compose
            chmod +x \$DOCKER_CONFIG/cli-plugins/docker-compose

            # Clone the repository and update .env file
            git clone -b release https://${{ secrets.GH_DEPLOY_TOKEN }}@github.com/${{ github.repository }} app
            cd app
            sed -i 's|VITE_API_URL=http://localhost:3000|VITE_API_URL=http://'"$PUBLIC_IP"':3000|' frontend/.env
            echo "${{ secrets.DOCKERHUB_TOKEN }}" | docker login -u "${{ secrets.DOCKERHUB_USERNAME }}" --password-stdin

            docker-compose up -d --build
          EOF
          
      - name: Display deployed app URL
        run: |
          echo "## ðŸŒ Deployed Web App URL" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "[Visit App](http://$PUBLIC_IP:5173)" >> $GITHUB_STEP_SUMMARY
